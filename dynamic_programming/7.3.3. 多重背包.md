# 7.3.3. 多重背包

多重背包问题：

有$n$种物品和一个容量为$C$的背包，每种物品有重量$w_{i}$和价值$v_{i}$两种属性，个数为$s_i$，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。与01背包不同，每种物品可以多次选；与完全背包不同，每种物品有个数上限。

1. 记忆化搜索
   + TC $O(c * \sum_{i=1}^{n}s_i)$

```python
# TC O(nck) c = capacity, k = max(s[i])
# SC O(nc)
def bouned_knapsack(capacity: int, w: List[int], v: List[int], s: List[int]) -> int:
    n = len(w)
    @cache
    def dfs(i, j):
        if i < 0:
            return 0
        ans = dfs(i-1, j)
        for k in range(1, s[i]+1):
            if j >= k * w[i]:
                ans = max(ans, dfs(i-1, j - k * w[i]) + k * v[i])
        return ans
    
    return dfs(n-1, capacity)
```

2. DP递推

```python
# TC O(nck)
# SC O(nc)
def bouned_knapsack(capacity: int, w: List[int], v: List[int], s: List[int]) -> int:
    n = len(w)
    f = [[0] * (capacity + 1) for _ in range(n + 1)]
    for i in range(n):
        for j in range(capacity, w[i]-1, -1):
            for k in range(1, s[i]+1):
                if j < k * w[i]:
                    f[i+1][j] = f[i][j]
                else:
                    f[i+1][j] = max(f[i+1][j], f[i+1][j - k * w[i]] + k * v[i])
    return f[n][capacity]
```

3. DP空间优化

```python
# TC O(nck)
# SC O(c)
def bouned_knapsack(capacity: int, w: List[int], v: List[int], s: List[int]) -> int:
    n = len(w)
    f = [0] * (capacity + 1)
    for i in range(n):
        for j in range(capacity, w[i]-1, -1):
            for k in range(1, s[i]+1):
                if j >= k * w[i]:
                    f[j] = max(f[j], f[j - k * w[i]] + k * v[i])
                else:
                    break
    return f[capacity]
```



## [2585. Number of Ways to Earn Points](https://leetcode.com/problems/number-of-ways-to-earn-points/)

## [3333. Find the Original Typed String II](https://leetcode.com/problems/find-the-original-typed-string-ii/)

## [2902. Count of Sub-Multisets With Bounded Sum](https://leetcode.com/problems/count-of-sub-multisets-with-bounded-sum/)

