# 7.3.3. 多重背包

多重背包问题：

有$n$种物品和一个容量为$C$的背包，每种物品有重量$w_{i}$和价值$v_{i}$两种属性，个数为$s_i$，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。与01背包不同，每种物品可以多次选；与完全背包不同，每种物品有个数上限。



- 如果区分相同数字，就是 0-1 背包。
- 如果不区分相同数字，就是多重背包。



1. 记忆化搜索
   + TC $O(c \cdot \sum_{i=1}^{n}s_i)$

```python
# TC O(nck) c = capacity, k = max(s[i])
# SC O(nc)
def bouned_knapsack(capacity: int, w: List[int], v: List[int], s: List[int]) -> int:
    n = len(w)
    @cache
    def dfs(i, j):
        if i < 0:
            return 0
        ans = dfs(i-1, j)
        for k in range(1, s[i]+1):
            if j >= k * w[i]:
                ans = max(ans, dfs(i-1, j - k * w[i]) + k * v[i])
        return ans
    
    return dfs(n-1, capacity)
```

2. DP递推

```python
# TC O(nck)
# SC O(nc)
def bouned_knapsack(capacity: int, w: List[int], v: List[int], s: List[int]) -> int:
    n = len(w)
    f = [[0] * (capacity + 1) for _ in range(n + 1)]
    for i in range(n):
        for j in range(capacity, w[i]-1, -1):
            for k in range(1, s[i]+1):
                if j < k * w[i]:
                    f[i+1][j] = f[i][j]
                else:
                    f[i+1][j] = max(f[i+1][j], f[i+1][j - k * w[i]] + k * v[i])
    return f[n][capacity]
```

3. DP空间优化

```python
# TC O(nck)
# SC O(c)
def bouned_knapsack(capacity: int, w: List[int], v: List[int], s: List[int]) -> int:
    n = len(w)
    f = [0] * (capacity + 1)
    for i in range(n):
        for j in range(capacity, w[i]-1, -1):
            for k in range(1, s[i]+1):
                if j >= k * w[i]:
                    f[j] = max(f[j], f[j - k * w[i]] + k * v[i])
                else:
                    break
    return f[capacity]
```



## [2585. Number of Ways to Earn Points](https://leetcode.com/problems/number-of-ways-to-earn-points/)

记忆化搜索

+ TC O(target * S) $S = \sum_{i=1}^{n}count_i$
+ SC O(target * n)

```python
class Solution:
    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:
        MOD = 1_000_000_007
        @cache
        def dfs(i, j):
            if i < 0:
                return j == 0

            cnt, x = types[i]
            ans = dfs(i - 1, j)
            for k in range(1, min(cnt, j // x) + 1):
                ans += dfs(i - 1, j - k * x)
            return ans

        n = len(types)
        return dfs(n - 1, target) % MOD

```

多重背包DP

+ TC O(target * S) $S = \sum_{i=1}^{n}count_i$
+ SC O(target * n)

```python
class Solution:
    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:
        MOD = 1_000_000_007
        n = len(types)
        f = [[0] * (target + 1) for _ in range(n + 1)]
        f[0][0] = 1
        for i, (cnt, x) in enumerate(types):
            for j in range(target, -1, -1):
                for k in range(0, min(cnt, j // x) + 1):
                    f[i+1][j] += f[i][j - k * x]
                f[i+1][j] %= MOD
        
        return f[n][target] % MOD
```

多重背包DP + 空间优化

+ TC O(target * S) $S = \sum_{i=1}^{n}count_i$
+ SC O(target)

```python
class Solution:
    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:
        MOD = 1_000_000_007
        f = [1] + [0] * target
        for cnt, x in types:
            # 这里跳过j = 0
            for j in range(target, 0, -1):
                # 这里跳过k = 0 即 f[j] += f[j]的情况
                # 因为只用了一个数组，上一个i的信息已经在数组里了
                for k in range(1, min(cnt, j // x) + 1):
                    f[j] += f[j - k * x]
                f[j] %= MOD
        return f[target] % MOD
```

注意到最内层循环中`f[j] += f[j - k * x]`

f(i, j) = f(i-1, j) + f(i-1, j-x) + f(i-1, j-2x) + ... + f(i-1, j-kx)

f(i, j-x) = f(i-1, j-x) + f(i-1, j-2x) + f(i-1, j-3x) + ... + f(i-1, j-(k+1)x)

错位相减得到f(i, j) = f(i, j-x) + f(i-1, j) - f(i-1, j-(k+1)x)

如果 j - (k+1)x < 0 由于无法组成负数，对应的方案数为0

即f(i, j) = f(i, j-x) + f(i-1, j) - [f(i-1, j-(k+1)x)]

这样就可以O(1)时间算出f(i, j)



等差数列优化（也是滑动窗口）

+ TC O(target * n)
+ SC O(target * n)

```python
class Solution:
    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:
        MOD = 1_000_000_007
        n = len(types)
        f = [[0] * (target + 1) for _ in range(n + 1)]
        f[0][0] = 1
        for i, (cnt, x) in enumerate(types):
            f[i + 1] = f[i].copy()
            for j in range(x, target + 1):
                f[i + 1][j] = f[i + 1][j - x] + f[i][j]
                if j >= (cnt + 1) * x:
                    f[i + 1][j] -= f[i][j - (cnt + 1) * x]
                f[i + 1][j] %= MOD

        return f[n][target] % MOD
```

等差数列 + 滚动数组

+ TC O(target * n)
+ SC O(target)

```python
class Solution:
    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:
        MOD = 1_000_000_007
        n = len(types)
        f = [1] + [0] * target
        s = 0
        for i, (cnt, x) in enumerate(types):
            s = min(target, s + cnt * x)
            prev_f = f.copy()
            for j in range(x, target + 1):
                f[j] += f[j - x]
                if j >= (cnt + 1) * x:
                    f[j] -= prev_f[j - (cnt + 1) * x]
                f[j] %= MOD

        return f[target] % MOD
```

等差数列 + 一个数组

1. 先倒序遍历：f(j) = f(j) - f(j-(k+1)x)
   由于是倒序遍历，此时的f(j-(k+1)x)还未被更新，
   依旧是上一轮的旧值，对应原方程中的f(i-1, j-(k+1)x)
2. 再正序遍历：f(j) = f(j) + f(j-x)
   此时的f(j-x)已经在前面更新过，
   是本轮的新值，对应原方程中的f(i, j-x)

+ TC O(target * n)
+ SC O(target)

```python
class Solution:
    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:
        MOD = 1_000_000_007
        n = len(types)
        f = [1] + [0] * target
        s = 0
        for i, (cnt, x) in enumerate(types):
            s = min(target, s + cnt * x)
            for j in range(s, (cnt + 1) * x - 1, -1):
                f[j] -= f[j - (cnt + 1) * x]
                f[j] %= MOD
            for j in range(x, s + 1):
                f[j] += f[j - x]
                f[j] %= MOD

        return f[target] % MOD
```

也可以理解为同余前缀和

$f(i, j) = \sum_{k=0}^{cnt}f(i-1, j - kx)$

如果求出f(i-1)的同余前缀和，即pre(p) = f(i-1, p) + f(i-1, p-x) + f(i-1, p-2x) + ...

得到pre(p) = f(i-1, p) + pre(p-x)

f(i, j) = pre(i-1, j) - pre(i-1, j-(cnt+1)*x)

用一个数组实现为

```python
for j in range(x, s + 1):
    f[j] = (f[j] + f[j - x]) % MOD # 原地计算同余前缀和
for j in range(s, (cnt + 1) * x - 1, -1):
    f[j] = (f[j] - f[j - (cnt + 1) * x]) % MOD # f(j) = pre(j) - pre(j - (cnt+1)*x)
```

单独计算前缀和pre数组

```python
class Solution:
    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:
        MOD = 1_000_000_007
        n = len(types)
        f = [1] + [0] * target
        s = 0
        for i, (cnt, x) in enumerate(types):
            s = min(target, s + cnt * x)
            pre = [1] + [0] * target
            for j in range(0, s + 1):
                pre[j] = f[j] + (pre[j - x] if j >= x else 0)
            for j in range(s, -1, -1):
                f[j] = pre[j] - (pre[j - (cnt + 1) * x] if j >= (cnt + 1) * x else 0)
                f[j] %= MOD

        return f[target] % MOD
```



## [3333. Find the Original Typed String II](https://leetcode.com/problems/find-the-original-typed-string-ii/)

## [2902. Count of Sub-Multisets With Bounded Sum](https://leetcode.com/problems/count-of-sub-multisets-with-bounded-sum/)

