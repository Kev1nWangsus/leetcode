# 7.4.1. 最长公共子序列

## [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)

子序列本质上就是选或不选，考虑最后一对字母记为x和y，有三种情况

1. 选x不选y
2. 不选x选y
3. 选x选y

回溯三问：

+ 当前操作：考虑s[i]和t[j]选或不选
+ 子问题：s的前i个字母和t的前j个字母的LCS长度
+ 下一个子问题：
  + 当且仅当s[i] == t[j], s的前i-1个字母和t的前j-1个字母的LCS长度
  + s的前i-1个字母和t的前j个字母的LCS长度
  + s的前i个字母和t的前i-1个字母的LCS长度


$dfs(i, j) = max(dfs(i-1, j), dfs(i, j-1), dfs(i-1, j-1) + (s[i] == t[j]))$

不能忽略的问题：

+ 在s[i] == t[j]时，只需要考虑都选的情况 dfs(i-1, j-1) + 1
+ 在s[i] != t[j]时，只能考虑 dfs(i-1, j) 和 dfs(i, j-1)

最终可以简化为
$$
dfs(i, j) = \Bigg\{\begin{array}{cc}dfs(i - 1, j - 1) + 1 & s[i] = t[j]\\
max(dfs(i-1, j), dfs(i, j-1))& s[i] \neq t[j]\end{array}
$$

1. 记忆化搜索模板

```python
# TC O(mn)
# SC O(mn)
class Solution:
    def longestCommonSubsequence(self, s: str, t: str) -> int:
        @cache
        def dfs(i, j):
            if i < 0 or j < 0:
                return 0
            if s[i] == t[j]:
                return dfs(i - 1, j - 1) + 1
            return max(dfs(i - 1, j), dfs(i, j - 1))

        m, n = len(s), len(t)
        return dfs(m - 1, n - 1)
```

2. DP递推模板

```python
# TC O(mn)
# SC O(mn)
class Solution:
    def longestCommonSubsequence(self, s: str, t: str) -> int:
        m, n = len(s), len(t)
        f = [[0] * (n + 1) for _ in range(m + 1)]

        for i, x in enumerate(s):
            for j, y in enumerate(t):
                if x == y:
                    f[i + 1][j + 1] = f[i][j] + 1
                else:
                    f[i + 1][j + 1] = max(f[i + 1][j], f[i][j + 1])
        return f[m][n]
```

3. DP空间优化1 - 两个一维数组

```python
# TC O(mn)
# SC O(min(m, n))
class Solution:
    def longestCommonSubsequence(self, s: str, t: str) -> int:
        if len(s) < len(t): 
            s, t = t, s
        n = len(t)
        pre_f = [0] * (n + 1)
        cur_f = [0] * (n + 1)

        for x in s:
            for j, y in enumerate(t):
                if x == y:
                    cur_f[j + 1] = pre_f[j] + 1
                else:
                    cur_f[j + 1] = max(pre_f[j + 1], cur_f[j])
            pre_f, cur_f = cur_f, pre_f
        return pre_f[n]
```

4. DP空间优化2 - 一个一维数组 + pre

```python
# TC O(mn)
# SC O(min(m, n))
class Solution:
    def longestCommonSubsequence(self, s: str, t: str) -> int:
        if len(s) < len(t):
            s, t = t, s
        n = len(t)
        f = [0] * (n + 1)
        for x in s:
            pre = 0
            for j, y in enumerate(t):
                tmp = f[j + 1]
                if x == y:
                    f[j + 1] = pre + 1
                else:
                    f[j + 1] = max(f[j + 1], f[j])
                pre = tmp
        return f[n]
```

