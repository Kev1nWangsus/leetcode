# 7.4.1. 最长公共子序列

## [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)

子序列本质上就是选或不选，考虑最后一对字母记为x和y，有三种情况

1. 选x不选y
2. 不选x选y
3. 选x选y

回溯三问：

+ 当前操作：考虑s[i]和t[j]选或不选
+ 子问题：s的前i个字母和t的前j个字母的LCS长度
+ 下一个子问题：
  + 当且仅当s[i] == t[j], s的前i-1个字母和t的前j-1个字母的LCS长度
  + s的前i-1个字母和t的前j个字母的LCS长度
  + s的前i个字母和t的前i-1个字母的LCS长度


$dfs(i, j) = max(dfs(i-1, j), dfs(i, j-1), dfs(i-1, j-1) + (s[i] == t[j]))$

不能忽略的问题：

+ 在s[i] == t[j]时，只需要考虑都选的情况 dfs(i-1, j-1) + 1
+ 在s[i] != t[j]时，只能考虑 dfs(i-1, j) 和 dfs(i, j-1)

最终可以简化为
$$
dfs(i, j) = \Bigg\{\begin{array}{cc}dfs(i - 1, j - 1) + 1 & s[i] = t[j]\\
max(dfs(i-1, j), dfs(i, j-1))& s[i] \neq t[j]\end{array}
$$

1. 记忆化搜索模板

```python
# TC O(mn)
# SC O(mn)
class Solution:
    def longestCommonSubsequence(self, s: str, t: str) -> int:
        @cache
        def dfs(i, j):
            if i < 0 or j < 0:
                return 0
            if s[i] == t[j]:
                return dfs(i - 1, j - 1) + 1
            return max(dfs(i - 1, j), dfs(i, j - 1))

        m, n = len(s), len(t)
        return dfs(m - 1, n - 1)
```

2. DP递推模板

```python
# TC O(mn)
# SC O(mn)
class Solution:
    def longestCommonSubsequence(self, s: str, t: str) -> int:
        m, n = len(s), len(t)
        f = [ [0] * (n + 1) for _ in range(m + 1) ]

        for i, x in enumerate(s):
            for j, y in enumerate(t):
                if x == y:
                    f[i + 1][j + 1] = f[i][j] + 1
                else:
                    f[i + 1][j + 1] = max(f[i + 1][j], f[i][j + 1])
        return f[m][n]
```

3. DP空间优化1 - 两个一维数组

```python
# TC O(mn)
# SC O(min(m, n))
class Solution:
    def longestCommonSubsequence(self, s: str, t: str) -> int:
        if len(s) < len(t): 
            s, t = t, s
        n = len(t)
        pre_f = [0] * (n + 1)
        cur_f = [0] * (n + 1)

        for x in s:
            for j, y in enumerate(t):
                if x == y:
                    cur_f[j + 1] = pre_f[j] + 1
                else:
                    cur_f[j + 1] = max(pre_f[j + 1], cur_f[j])
            pre_f, cur_f = cur_f, pre_f
        return pre_f[n]
```

4. DP空间优化2 - 一个一维数组 + pre

```python
# TC O(mn)
# SC O(min(m, n))
class Solution:
    def longestCommonSubsequence(self, s: str, t: str) -> int:
        if len(s) < len(t):
            s, t = t, s
        n = len(t)
        f = [0] * (n + 1)
        for x in s:
            pre = 0
            for j, y in enumerate(t):
                tmp = f[j + 1]
                if x == y:
                    f[j + 1] = pre + 1
                else:
                    f[j + 1] = max(f[j + 1], f[j])
                pre = tmp
        return f[n]
```



## [583. Delete Operation for Two Strings](https://leetcode.com/problems/delete-operation-for-two-strings/)

总长度 - 2 * lcs

lcs = Leetcode1143.longestCommonSubsequence(s, t)

记忆化搜索

+ TC $O(mn)$
+ SC $O(mn)$

```python
class Solution:
    def minDistance(self, s: str, t: str) -> int:
        @cache
        def dfs(i, j):
            if i < 0 or j < 0:
                return 0
            
            if s[i] == t[j]:
                return dfs(i - 1, j - 1) + 1
            
            return max(dfs(i - 1, j), dfs(i, j - 1))
        m, n = len(s), len(t)
        lcs = dfs(m - 1, n - 1)
        return m + n - 2 * lcs
```

DP递推

```python
class Solution:
    def minDistance(self, s: str, t: str) -> int:
        m, n = len(s), len(t)
        f = [ [0] * (n + 1) for _ in range(m + 1) ]
        for i, x in enumerate(s):
            for j, y in enumerate(t):
                if x == y:
                    f[i + 1][j + 1] = f[i][j] + 1
                else:
                    f[i + 1][j + 1] = max(f[i][j + 1], f[i + 1][j])

        return m + n - 2 * f[m][n]
```

DP空间优化

+ TC $O(mn)$
+ SC $O(min(m, n))$

```python
class Solution:
    def minDistance(self, s: str, t: str) -> int:
        if len(s) < len(t):
            s, t = t, s
        
        m, n = len(s), len(t)
        f = [0] * (n + 1)
        for x in s:
            pre = 0
            for j, y in enumerate(t):
                tmp = f[j + 1]
                if x == y:
                    f[j + 1] = pre + 1
                else:
                    f[j + 1] = max(f[j + 1], f[j])
                pre = tmp

        return m + n - 2 * f[n]
```



## [712. Minimum ASCII Delete Sum for Two Strings](https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/)

总ASCII码和 - lcs_ASCII_sum

记忆化搜索

+ TC $O(mn)$
+ SC $O(mn)$

```python
class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        s1 = [ord(ch) for ch in s1]
        s2 = [ord(ch) for ch in s2]

        @cache
        def dfs(i, j):
            if i < 0 or j < 0:
                return 0
            
            if s1[i] == s2[j]:
                return dfs(i - 1, j - 1) + s1[i]
            
            return max(dfs(i - 1, j), dfs(i, j - 1))
        
        m, n = len(s1), len(s2)
        lcs_ascii_sum = dfs(m - 1, n - 1)
        return sum(s1) + sum(s2) - 2 * lcs_ascii_sum
```

DP递推

+ TC $O(mn)$
+ SC $O(mn)$

```python
class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        s1 = [ord(ch) for ch in s1]
        s2 = [ord(ch) for ch in s2]
        m, n = len(s1), len(s2)
        f = [ [0] * (n + 1) for _ in range(m + 1) ]
        for i, x in enumerate(s1):
            for j, y in enumerate(s2):
                if x == y:
                    f[i + 1][j + 1] = f[i][j] + x
                else:
                    f[i + 1][j + 1] = max(f[i][j + 1], f[i + 1][j])

        return sum(s1) + sum(s2) - 2 * f[m][n]
```

DP空间优化

+ TC $O(mn)$
+ SC $O(min(m, n))$

```python
class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        if len(s1) < len(s2):
            s1, s2 = s2, s1
        
        s1 = [ord(ch) for ch in s1]
        s2 = [ord(ch) for ch in s2]
        m, n = len(s1), len(s2)
        f = [0] * (n + 1)
        for x in s1:
            pre = 0
            for j, y in enumerate(s2):
                tmp = f[j + 1]
                if x == y:
                    f[j + 1] = pre + x
                else:
                    f[j + 1] = max(f[j + 1], f[j])
                pre = tmp

        return sum(s1) + sum(s2) - 2 * f[n]
```

