# 7.4.2. 最长递增子序列

## [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)

本题可以使用动态规划，也可以使用贪心，大致有4种思路

1. 动态规划，对于每个i，枚举前面选哪些数字
2. 动态规划，去重排序后的sorted_arr与原数组arr求LCS
3. 贪心+二分 （数论）
4. 数据结构线段树优化



1. 动态规划 LIS

+ 记忆化搜索模板

  ```python
  # TC O(n^2)
  # SC O(n)
  class Solution:
      def lengthOfLIS(self, nums: List[int]) -> int:
          n = len(nums)
  
          @cache
          def dfs(i):
              res = 0
              for j in range(i):
                  if nums[j] < nums[i]:
                      res = max(res, dfs(j))
              return res + 1
          
          return max(dfs(i) for i in range(n))
  ```
  
+ DP递推模板

  ```python
  # TC O(n^2)
  # SC O(n)
  class Solution:
      def lengthOfLIS(self, nums: List[int]) -> int:
          n = len(nums)
          f = [0] * n
          for i in range(n):
              for j in range(i):
                  if nums[j] < nums[i]:
                      f[i] = max(f[i], f[j])
              f[i] += 1
          
          return max(f)
  ```
  

2. 动态规划 LCS

   ```python
   # TC O(n^2)
   # SC O(n^2)
   class Solution:
       def lengthOfLIS(self, nums: List[int]) -> int:
           def lcs(s, t):
               m, n = len(s), len(t)
               f = [[0] * (n + 1) for _ in range(m + 1)]
               for i in range(m):
                   for j in range(n):
                       if s[i] == t[j]:
                           f[i + 1][j + 1] = f[i][j] + 1
                       else:
                           f[i + 1][j + 1] = max(f[i][j + 1], f[i + 1][j])
               return f[m][n]
   
           sorted_arr = sorted(list(set(nums)))
           return lcs(sorted_arr, nums)
   ```

3. 贪心 + 二分

   进一步优化动态规划，交换状态与状态值

   $f[i]$ 表示末尾元素为`nums[i]`的 最长递增子序列 长度

   $g[i]$ 表示末尾元素为`i+1` 的 递增子序列 的末尾元素的最小值

   此时因为 $g$ 数组严格递增，可以用二分查找$O(logn)$找到 $g$ 数组中第一个大于等于`nums[i]` 的数字并替换，如果没找到，则添加`nums[i]` 至 $g$ 数组末尾。最后返回 $g$ 数组长度即为LIS。

   ```python
   # TC O(nlogn)
   # SC O(n)
   class Solution:
       def lengthOfLIS(self, nums: List[int]) -> int:
           g = []
           for x in nums:
               j = bisect_left(g, x) # O(logn)
               if j == len(g):
                   g.append(x)
               else:
                   g[j] = x
           return len(g)
   
   # TC O(nlogn)
   # SC O(1) 原地修改
   class Solution:
       def lengthOfLIS(self, nums: List[int]) -> int:
           ng = 0
           for x in nums:
               j = bisect_left(nums, x, 0, ng)
               nums[j] = x
               if j == ng:
                   ng += 1
           return ng
   ```

   题目变形：不要求子序列严格递增（non-decreasing 即可）

   在修改 $g$ 数组时，应当修改 $g$ 数组中第一个*大于* `nums[i]` 的数字，python使用bisect_right即可

   ```python
   # TC O(nlogn)
   # SC O(n)
   class Solution:
       def lengthOfLIS(self, nums: List[int]) -> int:
           g = []
           for x in nums:
               j = bisect_right(g, x) # O(logn)
               if j == len(g):
                   g.append(x)
               else:
                   g[j] = x
           return len(g)
   ```

   



## [2826. Sorting Three Groups](https://leetcode.com/problems/sorting-three-groups/)

数组长度 - 最长非递减子序列长度 (LIS, 不要求严格递增)

DP递推

+ TC O(n^2)
+ SC O(n)

```python
class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        n = len(nums)
        f = [0] * n
        for i, x in enumerate(nums):
            for j in range(i):
                if nums[j] <= x:
                    f[i] = max(f[i], f[j])
            f[i] += 1
        return n - max(f)
```

贪心 + 二分

```python
class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        n = len(nums)
        g = []
        for x in nums:
            j = bisect_right(g, x)
            if j == len(g):
                g.append(x)
            else:
                g[j] = x
        return n - len(g)
```



## [1671. Minimum Number of Removals to Make Mountain Array](https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/)

