# 7.3.1. 01背包

01背包问题：

有$n$个物品和一个容量为$C$的背包，每个物品有重量$w_{i}$和价值$v_{i}$两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。



思考：high-level idea为选或不选，适合用回溯爆搜。

回溯三问：

+ 当前操作：枚举第i个物品选或不选，
  + 选，背包容量减少w[i]，价值增加v[i]
  + 不选，剩余容量不变，价值不变
+ 子问题：在剩余容量为j时，从前i个物品得到的最大价值和
+ 下一个子问题：分类讨论
  + 选，在剩余容量为j-w[i]时，从前i-1个物品获得的最大价值和
  + 不选，在剩余容量为c时，从前i个物品获得的最大价值和

dfs(i, j) = max(dfs(i-1, j), dfs(i-1, j-w[i]) + v[i])

爆搜时间复杂度为O(2^n)，添加记忆化或DP数组降为O(nc)

1. 记忆化搜索

```python
# TC O(nc) c = capacity
# SC O(nc)
def zero_one_knapsack(capacity: int, w: List[int], v: List[int]) -> int:
    n = len(w)
    
    @cache
    def dfs(i, j):
        if i < 0:
            return 0
       	if c < w[i]:
            return dfs(i-1, j)
        return max(dfs(i-1, j), dfs(i-1, j-w[i]) + v[i])
    
    return dfs(n-1, capacity)
```

2. DP递推

f(i, j)表示在只能放前i个物品的情况下，背包容量为j所能拿到的最大价值和

$f(i, j) = max(f(i-1, j), f(i-1, j-w[i]) + v[i])$

```python
# TC O(nc)
# SC O(nc)
def zero_one_knapsack(capacity: int, w: List[int], v: List[int]) -> int:
    n = len(w)
    f = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    for i in range(n):
        for j in range(capacity+1):
            if j < w[i]:
                f[i+1][j] = f[i][j]
            else:
                f[i+1][j] = max(f[i][j], f[i][j - w[i]] + v[i])
    return f[n][capacity]
```

3. DP空间优化 - 滚动数组（两个数组）

观察到f(i)只会取决于f(i-1)，所以只需要使用两个数组即可

```python
# TC O(nc)
# SC O(c)
def zero_one_knapsack(capacity: int, w: List[int], v: List[int]) -> int:
    n = len(w)
    f = [[0] * (capacity + 1) for _ in range(2)]
    
    for i in range(n):
        for j in range(capacity+1):
            if j < w[i]:
                f[(i+1) % 2][j] = f[i % 2][j]
            else:
                f[(i+1) % 2][j] = max(f[i % 2][j], f[i % 2][j - w[i]] + v[i])
    return f[n % 2][capacity]
```

4. DP空间优化 - 一个数组

同上，使用一个数组也是可以的，但需要调整内层循环顺序为从后往前，观察如下例子

递推公式优化第一维度后 得到 f(j) = f(j) + f(j - w[i])

对于处理当前物品i和当前状态f(i, j)，在j>=w[i]时，如果按照正序处理，f(i, j)是会被f(i, j-w[i])影响的，相当于物品i可以又再一次被放入背包，与01背包题意不符。所以倒序枚举j，这样在更新f(i, j-w[i])时，f(i, j)已经被正确更新了，w[i]>=0。

```python
# TC O(nc)
# SC O(c)
def zero_one_knapsack(capacity: int, w: List[int], v: List[int]) -> int:
    n = len(w)
    f = [0] * (capacity + 1)
    
    for i in range(n):
        for j in range(capacity+1, w[i]-1, -1):
            f[j] = max(f[j], f[j - w[i]] + v[i])
    return f[capacity]
```

