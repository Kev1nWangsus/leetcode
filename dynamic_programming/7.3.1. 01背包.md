# 7.3.1. 01背包

01背包问题：

有$n$个物品和一个容量为$C$的背包，每个物品有重量$w_{i}$和价值$v_{i}$两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。



思考：high-level idea为选或不选，适合用回溯爆搜。

回溯三问：

+ 当前操作：枚举第i个物品选或不选，
  + 选，背包容量减少w[i]，价值增加v[i]
  + 不选，剩余容量不变，价值不变
+ 子问题：在剩余容量为j时，从前i个物品得到的最大价值和
+ 下一个子问题：分类讨论
  + 选，在剩余容量为j-w[i]时，从前i-1个物品获得的最大价值和
  + 不选，在剩余容量为c时，从前i个物品获得的最大价值和

dfs(i, j) = max(dfs(i-1, j), dfs(i-1, j-w[i]) + v[i])

爆搜时间复杂度为O(2^n)，添加记忆化或DP数组降为O(nc)

1. 记忆化搜索

```python
# TC O(nc) c = capacity
# SC O(nc)
def zero_one_knapsack(capacity: int, w: List[int], v: List[int]) -> int:
    n = len(w)
    
    @cache
    def dfs(i, j):
        if i < 0:
            return 0
       	if c < w[i]:
            return dfs(i-1, j)
        return max(dfs(i-1, j), dfs(i-1, j-w[i]) + v[i])
    
    return dfs(n-1, capacity)
```

2. DP递推

f(i, j)表示在只能放前i个物品的情况下，背包容量为j所能拿到的最大价值和

$f(i, j) = max(f(i-1, j), f(i-1, j-w[i]) + v[i])$

```python
# TC O(nc)
# SC O(nc)
def zero_one_knapsack(capacity: int, w: List[int], v: List[int]) -> int:
    n = len(w)
    f = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    for i in range(n):
        for j in range(capacity+1):
            if j < w[i]:
                f[i+1][j] = f[i][j]
            else:
                f[i+1][j] = max(f[i][j], f[i][j - w[i]] + v[i])
    return f[n][capacity]
```

3. DP空间优化 - 滚动数组（两个数组）

观察到f(i)只会取决于f(i-1)，所以只需要使用两个数组即可

```python
# TC O(nc)
# SC O(c)
def zero_one_knapsack(capacity: int, w: List[int], v: List[int]) -> int:
    n = len(w)
    f = [[0] * (capacity + 1) for _ in range(2)]
    
    for i in range(n):
        for j in range(capacity+1):
            if j < w[i]:
                f[(i+1) % 2][j] = f[i % 2][j]
            else:
                f[(i+1) % 2][j] = max(f[i % 2][j], f[i % 2][j - w[i]] + v[i])
    return f[n % 2][capacity]
```

4. DP空间优化 - 一个数组

同上，使用一个数组也是可以的，但需要调整内层循环顺序为从后往前，观察如下例子

递推公式优化第一维度后 得到 f(j) = f(j) + f(j - w[i])

对于处理当前物品i和当前状态f(i, j)，在j>=w[i]时，如果按照正序处理，f(i, j)是会被f(i, j-w[i])影响的，相当于物品i可以又再一次被放入背包，与01背包题意不符。所以倒序枚举j，这样在更新f(i, j-w[i])时，f(i, j)已经被正确更新了，w[i]>=0。

```python
# TC O(nc)
# SC O(c)
def zero_one_knapsack(capacity: int, w: List[int], v: List[int]) -> int:
    n = len(w)
    f = [0] * (capacity + 1)
    
    for i in range(n):
        for j in range(capacity+1, w[i]-1, -1):
            f[j] = max(f[j], f[j - w[i]] + v[i])
    return f[capacity]
```



## [2915. Length of the Longest Subsequence That Sums to Target](https://leetcode.com/problems/length-of-the-longest-subsequence-that-sums-to-target/)

记忆化搜索

+ TC O(n * target)
+ SC O(n * target)

```python
class Solution:
    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:
        @cache
        def dfs(i, j):
            if i < 0:
                return 0 if j == 0 else -inf

            return max(dfs(i-1, j), 1 + dfs(i-1, j - nums[i]) if j >= nums[i] else -inf)
        
        n = len(nums)
        ans = dfs(n-1, target)
        dfs.cache_clear()
        return ans if ans != -inf else -1
```

背包DP

+ TC O(n * target)
+ SC O(n * target)

```python
class Solution:
    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:
        n = len(nums)
        f = [[-inf] * (target + 1) for _ in range(n + 1)]
        f[0][0] = 0
        for i, x in enumerate(nums):
            # 更快一点
            f[i + 1] = f[i].copy()
            for j in range(x, target + 1):
                f[i + 1][j] = max(f[i][j], f[i][j - x] + 1)
            
            # 挨个填慢一点
            # for j in range(target + 1):
            #     if j < x:
            #         f[i + 1][j] = f[i][j]
            #     else:
            #         f[i + 1][j] = max(f[i][j], f[i][j - x] + 1)

			
        return f[n][target] if f[n][target] != -inf else -1
```

背包DP空间优化 （倒序填写）

+ TC O(n * target)
+ SC O(target)

```python
class Solution:
    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:
        f = [-inf] * (target + 1)
        f[0] = 0
        for x in nums:
            for j in range(target, x-1, -1):
                f[j] = max(f[j], f[j - x] + 1)

        return f[target] if f[target] != -inf else -1
```

细节优化

```python
class Solution:
    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:
        f = [-inf] * (target + 1)
        f[0] = 0
        s = 0 # 记录当前最大和，避免无意义的更新
        for x in nums:
            s = min(s + x, target)
            for j in range(s, x-1, -1):
                f[j] = max(f[j], f[j - x] + 1)

        return f[target] if f[target] != -inf else -1
```



## [416. Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/)

记忆化搜索

+ TC O(n * target) target = sum(nums) // 2

+ SC O(n * target)

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        n = len(nums)
        s = sum(nums)
        if s % 2:
            return False

        target = s // 2
        
        @cache
        def dfs(i, c):
            if i < 0:
                return c == 0

            if c < nums[i]:
                return dfs(i - 1, c)

            return dfs(i - 1, c) or dfs(i - 1, c - nums[i])

        return dfs(n - 1, target)
```

背包DP + 空间优化（倒序）

+ TC O(n * target)

+ SC O(target)

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        n = len(nums)
        s = sum(nums)
        if s % 2:
            return False

        target = s // 2
        f = [False] * (target + 1)
        f[0] = True
        m = 0
        for x in nums:
            m = min(m + x, target)
            for j in range(m, x - 1, -1):
                f[j] = f[j] or f[j - x]

        return f[target]
```



## [494. Target Sum](https://leetcode.com/problems/target-sum/)

p + q = sum(nums)

p - q = target

取 `(sum(nums) - abs(target)) // 2` 作为目标和最省

记忆化搜索

+ TC O(nm)  m = (sum(nums) - abs(target)) // 2
+ SC O(nm)

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        s = sum(nums) - abs(target)
        if s % 2 or s < 0:  # impossible to have equal sum for two groups
            return 0
        m = s // 2 # 背包容量
        n = len(nums)

        @cache
        def dfs(i, c):
            if i < 0:
                return int(c == 0)
            if c < nums[i]:
                return dfs(i - 1, c)
            return dfs(i - 1, c) + dfs(i - 1, c - nums[i])

        return dfs(n - 1, m)
```

背包DP + 空间优化（倒序）

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        s = sum(nums) - abs(target)
        if s % 2 or s < 0:  # impossible to have equal sum for two groups
            return 0
        m = s // 2
        n = len(nums)
        f = [0] * (m + 1)
        f[0] = 1
        k = 0
        for x in nums:
            k = min(k + x, m)
            for j in range(k, x - 1, -1):
                f[j] += f[j - x]
        return f[m]
```



## [2787. Ways to Express an Integer as Sum of Powers](https://leetcode.com/problems/ways-to-express-an-integer-as-sum-of-powers/)

记忆化搜索

+ TC O($n \sqrt[x]{n}$)
+ SC O($n \sqrt[x]{n}$)

```python
class Solution:
    def numberOfWays(self, n: int, x: int) -> int:
        MOD = 1_000_000_007

        @cache
        def dfs(i, c):
            if c == 0:
                return 1

            if i < 0:
                return 0

            if c < i**x:
                return dfs(i - 1, c) % MOD
            return (dfs(i - 1, c - i**x) + dfs(i - 1, c)) % MOD

        maxi = ceil(pow(n, 1 / x))
        ans = dfs(maxi, n) % MOD
        dfs.cache_clear()
        return ans
```

背包DP + 空间优化（倒序）

+ TC O($n \sqrt[x]{n}$)
+ SC O(n)

```python
class Solution:
    def numberOfWays(self, n: int, x: int) -> int:
        MOD = 1_000_000_007
        f = [0] * (n + 1)
        f[0] = 1
        for i in range(1, n + 1):
            v = i**x
            if v > n:
                break

            for j in range(n, v - 1, -1):
                f[j] += f[j - v] % MOD

        return f[n] % MOD
```



## [3180. Maximum Total Reward Using Operations I](https://leetcode.com/problems/maximum-total-reward-using-operations-i/)

## [3181. Maximum Total Reward Using Operations II](https://leetcode.com/problems/maximum-total-reward-using-operations-ii/)

二维背包DP

f(i, j) bool表示是否能从前i个数中得到总奖励j

v = nums[i]

+ 不选 v，问题变成能否从前 i−1 个数中得到总奖励 j，即 f(i, j) = f(i-1, j)
+ 选 v，问题变成能否从前 i−1 个数中得到总奖励 j−v，即 f(i, j) = f(i-1, j-v)，前提是 j 满足 $j ≥ v$ 且 $j−v<v$，即 $v≤j<2v$。

一维背包DP 可以优化第一个维度 f(j) |= f(j - v), $v≤j<2v$

+ TC O(nm + nlogn)  m = max(nums)
+ SC O(m)

```python
class Solution:
    def maxTotalReward(self, nums: List[int]) -> int:
        nums = sorted(list(set(nums)))
        n = len(nums)
        maxi = max(nums)

        f = [False] * (2 * maxi)
        f[0] = True
        for i, v in enumerate(nums):
            for j in range(2 * v - 1, v - 1, -1):
                if f[j - v]:
                    f[j] = True

        for j in range(2 * maxi - 1, -1, -1):
            if f[j]:
                return j

        return -1
```

bitset/bigint 优化

f(j) |= f(j - v)可以优化f数组为一个数字，简化为取f的低v位，左移v位，OR到f中

`f |= (f & ((1 << v) - 1)) << v`

+ `(1 << v) - 1)` 得到一个低v位全是1的数
+ `f & ((1 << v) - 1)` 得到f的低v位
+ `(f & ((1 << v) - 1)) << v` 把f的低v位，左移v位

答案为f最高位，即f的二进制长度-1

+ TC O(nm/w + nlogn) `m = max(nums)` `w = 32 or 64`
+ SC O(n + m/w)

```python
class Solution:
    def maxTotalReward(self, rewardValues: List[int]) -> int:
        f = 1
        for v in sorted(set(rewardValues)):
            f |= (f & ((1 << v) - 1)) << v
        return f.bit_length() - 1
```



## [474. Ones and Zeroes](https://leetcode.com/problems/ones-and-zeroes/)

记忆化搜索

+ TC O(nmL) L = len(strs)
+ SC O(nmL)

```python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        cnts = [Counter(s) for s in strs]
        l = len(strs)

        @cache
        def dfs(i, j, k):
            if i < 0:
                return 0
            cnt_0 = cnts[i]["0"]
            cnt_1 = cnts[i]["1"]
            if cnt_0 > j or cnt_1 > k:
                return dfs(i - 1, j, k)
            return max(dfs(i - 1, j - cnt_0, k - cnt_1) + 1, dfs(i - 1, j, k))

        return dfs(l - 1, m, n)
```

背包DP + 空间优化（倒序）

+ TC O(nmL)
+ SC O(nm)

```python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        cnts = [Counter(s) for s in strs]
        l = len(strs)
        f = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(l):
            cnt_0 = cnts[i]["0"]
            cnt_1 = cnts[i]["1"]
            for j in range(m, cnt_0 - 1, -1):
                for k in range(n, cnt_1 - 1, -1):
                    f[j][k] = max(f[j - cnt_0][k - cnt_1] + 1, f[j][k])

        return f[m][n]
```



## [1049. Last Stone Weight II](https://leetcode.com/problems/last-stone-weight-ii/)

题目转化为

将石头分成两堆，第一堆和为t，第二堆和为(s-t)，且 t < (s-t) 最后剩下的石头质量为$(s - t) - t = s - 2* t$

要求 $s - 2*t$ 尽可能小，即求t的最大值，且 $t <= s // 2$，转化为求从stones里拿石头，背包容量为s//2

记忆化搜索

+ TC O(nm) m = sum(stones)
+ SC O(nm)

```python
class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        # minimize s - 2 * t
        s = sum(stones)
        target = s // 2

        @cache
        def dfs(i, j):
            if i < 0:
                return j

            if j >= stones[i]:
                return min(dfs(i - 1, j - stones[i]), dfs(i - 1, j))

            return dfs(i - 1, j)

        n = len(stones)
        delta = dfs(n - 1, target)
        t = target - delta
        return s - 2 * t

```

背包DP + 空间优化

+ TC O(nm)
+ SC O(m)

```python
class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        # minimize s - 2 * t
        s = sum(stones)
        target = s // 2

        f = [True] + [False] * target
        for i, x in enumerate(stones):
            for j in range(target, x - 1, -1):
                if f[j - x]:
                    f[j] = True

        for t in range(target, -1, -1):
            if f[t]:
                return s - 2 * t
```

