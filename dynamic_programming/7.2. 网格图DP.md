# 7.2. 网格图DP

## [62. Unique Paths](https://leetcode.com/problems/unique-paths/)

不推荐使用记忆化搜索，可能会涉及不必要的边界check

一般递推做法：

1. 给定m*n的矩阵，构建m\*n的f数组
2. 状态转移一般发生在相邻格子间的移动，如本题从上方或者左方相加转移得到f[i\][j\] = f[i-1\][j\] + f[i\][j-1\]
3. 观察状态转移取决于几个变量可以空间优化



1. DP模板

   ```python
   # TC O(mn)
   # SC O(mn)
   def uniquePaths(self, m: int, n: int) -> int:
       f = [[1] * n for _ in range(m)]
       for i in range(1, m):
           for j in range(1, n):
               f[i][j] = f[i-1][j] + f[i][j-1]
   
       return f[m-1][n-1]
   ```
   
2. DP空间优化

   f(i, j)仅取决于第i行和第i-1行的状态，可以使用滚动数组代替

   ```python
   # TC O(mn)
   # SC O(min(m,n))
   def uniquePaths(self, m: int, n: int) -> int:
       f = [1] * n
       for i in range(1, m):
           for j in range(1, n):
               f[j] += f[j-1]
   
       return f[n-1]
   ```

   



## [63. Unique Paths II](https://leetcode.com/problems/unique-paths-ii/)

初始化数组第一列和第一行的时候需要注意如果有障碍物，后续都是无法到达

+ TC O(mn)
+ SC O(mn)

```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        if obstacleGrid[0][0] or obstacleGrid[m-1][n-1]:
            return 0

        f = [ [0] * n for _ in range(m) ]
        
        for i in range(m):
            if obstacleGrid[i][0]:
                break
            f[i][0] = 1
        for j in range(n):
            if obstacleGrid[0][j]:
                break
            f[0][j] = 1

        for i in range(1, m):
            for j in range(1, n):
                if not obstacleGrid[i][j]:
                    f[i][j] = f[i-1][j] + f[i][j-1]
        
        return f[m-1][n-1]
```

空间优化，第i行只取决于第i行和i-1行

+ TC O(mn)
+ SC O(n)

```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        if obstacleGrid[0][0] or obstacleGrid[m-1][n-1]:
            return 0

        f = [0] * n     
        f[0] = 1

        for i in range(0, m):
            for j in range(0, n):
                if obstacleGrid[i][j]:
                    f[j] = 0   
                elif j >= 1 and not obstacleGrid[i][j-1]:
                    f[j] += f[j-1]
        
        return f[-1]
```



## [64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/)

f(i,j) = min(f(i-1,j), f(i, j-1)) + grid(i, j)

+ TC O(mn)
+ SC O(mn)

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        f = [[inf] * (n) for _ in range(m)]
        f[0][0] = grid[0][0]
        for i in range(1, m):
            f[i][0] = f[i-1][0] + grid[i][0]
        for j in range(1, n):
            f[0][j] = f[0][j-1] + grid[0][j]

        for i in range(1, m):
            for j in range(1, n):
                f[i][j] = min(f[i-1][j], f[i][j-1]) + grid[i][j]

        return f[-1][-1]
```

空间优化，第i行只取决于第i行和第i-1行

+ TC O(mn)
+ SC O(n)

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        f = [inf] * n
        f[0] = 0
        for i in range(m):
            f[0] = f[0] + grid[i][0] 
            for j in range(1, n):
                f[j] = min(f[j-1], f[j]) + grid[i][j]
        
        return f[-1]
```



## [120. Triangle](https://leetcode.com/problems/triangle/)

DFS记忆化搜索 (不用检查边界条件)

+ TC O(n^2)
+ SC O(n^2)

```python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)
        @cache
        def dfs(i, j):
            if i == n:
                return 0

            return min(dfs(i+1, j), dfs(i+1, j+1)) + triangle[i][j]
        
        return dfs(0, 0)
```

DP递推

+ TC O(n^2)
+ SC O(n^2)

```python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)
        f = [[0] * (i + 1) for i in range(n)]
        f[-1] = triangle[-1]
        for i in range(n - 2, -1, -1):
            for j, x in enumerate(triangle[i]):
                f[i][j] = min(f[i + 1][j], f[i + 1][j + 1]) + x
        return f[0][0]
```





## [931. Minimum Falling Path Sum](https://leetcode.com/problems/minimum-falling-path-sum/)

+ TC O(n^2)
+ SC O(n^2)

```python
class Solution:
    def minFallingPathSum(self, matrix: List[List[int]]) -> int:
        n = len(matrix)
        f = [[0] * n for _ in range(n)]
        f[0] = matrix[0]
        for i in range(1, n):
            for j in range(n):
                f[i][j] = min(
                    f[i-1][j], 
                    f[i-1][j-1] if j > 0 else inf,
                    f[i-1][j+1] if j < n-1 else inf
                ) + matrix[i][j]
        
        return min(f[-1])
```

空间优化

+ TC O(n^2)
+ SC O(n)

```python
class Solution:
    def minFallingPathSum(self, matrix: List[List[int]]) -> int:
        n = len(matrix)
        f = matrix[0]
        for i in range(1, n):
            t = [0] * n
            for j in range(n):
                t[j] = min(
                    f[j], 
                    f[j-1] if j > 0 else inf,
                    f[j+1] if j < n-1 else inf
                ) + matrix[i][j]
            f = t
        return min(f)
```



## [2684. Maximum Number of Moves in a Grid](https://leetcode.com/problems/maximum-number-of-moves-in-a-grid/)

+ TC O(mn)
+ SC O(mn)

```python
class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])

        f = [[-inf] * n for _ in range(m)]
        for i in range(m):
            f[i][0] = 0

        ans = 0
        for j in range(1, n):
            for i in range(m):
                x = grid[i][j]
                prev_max = max(
                    f[i][j-1] if grid[i][j-1] < x else -inf,
                    f[i-1][j-1] if i > 0   and grid[i-1][j-1] < x else -inf,
                    f[i+1][j-1] if i < m-1 and grid[i+1][j-1] < x else -inf
                ) + 1
                f[i][j] = prev_max
                ans = max(ans, f[i][j])
        return ans if ans != -inf else 0
```



## [2304. Minimum Path Cost in a Grid](https://leetcode.com/problems/minimum-path-cost-in-a-grid/)

记忆化搜索

+ TC O(mn^2) = O(mn)个状态*O(n)每个状态计算时间
+ SC O(mn)

```python
class Solution:
    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        @cache
        def dfs(i, j):
            if i == m-1:
                return grid[i][j]
            
            ans = inf
            v = grid[i][j]
            for k in range(n):
                ans = min(ans, moveCost[v][k] + dfs(i+1, k))
            return ans + v
        
        return min(dfs(0, k) for k in range(n))
```

DP

+ TC O(mn^2)

+ SC O(mn)

```python
class Solution:
    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        f = [[inf] * n for _ in range(m)]
        f[-1] = grid[-1]
        for i in range(m-2, -1, -1):
            for j in range(n):
                res = inf
                for k in range(n): # O(n)
                    res = min(res, moveCost[v][k] + f[i+1][k])
                f[i][j] = res + grid[i][j]
        return min(f[0][j] for j in range(n))
```



## [1289. Minimum Falling Path Sum II](https://leetcode.com/problems/minimum-falling-path-sum-ii/)

记忆化搜索

+ TC O(n^3)
+ SC O(n^2)

```python
class Solution:
    def minFallingPathSum(self, grid: List[List[int]]) -> int:
        n = len(grid)
        if n == 1:
            return min(min(grid))

        @cache
        def dfs(i, j):
            if i == n:
                return 0
            
            return grid[i][j] + min(dfs(i+1, k) if k != j else inf for k in range(n))
        
        return min(dfs(0, k) for k in range(n))
```

DP

+ TC O(n^3)
+ SC O(n^2)

```python
class Solution:
    def minFallingPathSum(self, grid: List[List[int]]) -> int:
        n = len(grid)
        f = [[inf] * n for _ in range(n)]
        f[0] = grid[0]
        for i in range(1, n):
            for j in range(n):
                f[i][j] = grid[i][j] + min(f[i-1][k] if k != j else inf for k in range(n))
        
        return min(f[-1])
```

DP转移过程优化

只需维护第 i−1 行相关的三个变量（最小值，最小值下标和次小值）

+ TC O(n^2)
+ SC O(1)

```python
class Solution:
    def minFallingPathSum(self, grid: List[List[int]]) -> int:
        n = len(grid)
        first_min = 0
        first_min_index = -1
        second_min = 0

        for i in range(n):
            cur_first_min = inf
            cur_first_min_index = -1
            cur_second_min = inf
            for j, x in enumerate(grid[i]):
                cur_sum = x + (first_min if j != first_min_index else second_min)
                if cur_sum < cur_first_min:
                    cur_second_min = cur_first_min
                    cur_first_min = cur_sum
                    cur_first_min_index = j
                elif cur_sum < cur_second_min:
                    cur_second_min = cur_sum
            
            first_min = cur_first_min
            first_min_index = cur_first_min_index
            second_min = cur_second_min

        return first_min
```



## [1594. Maximum Non Negative Product in a Matrix](https://leetcode.com/problems/maximum-non-negative-product-in-a-matrix/)

负负得正，所以遍历过程中同时维护最小值 

+ TC O(mn)
+ SC O(mn)

```python
class Solution:
    def maxProductPath(self, grid: List[List[int]]) -> int:
        MOD = 10 ** 9 + 7
        m, n = len(grid), len(grid[0])
        # [min, max]
        f = [[[1] * 2 for _ in range(n)] for _ in range(m)]

        f[0][0] = [grid[0][0], grid[0][0]]
        for i in range(1, m):
            f[i][0] = [f[i-1][0][0] * grid[i][0], f[i-1][0][1] * grid[i][0]]
        for j in range(1, n):
            f[0][j] = [f[0][j-1][0] * grid[0][j], f[0][j-1][1] * grid[0][j]]
        
        for i in range(1, m):
            for j in range(1, n):
                if grid[i][j] > 0:
                    f[i][j][0] = min(f[i-1][j][0], f[i][j-1][0]) * grid[i][j]
                    f[i][j][1] = max(f[i-1][j][1], f[i][j-1][1]) * grid[i][j]
                else:
                    f[i][j][1] = min(f[i-1][j][0], f[i][j-1][0]) * grid[i][j]
                    f[i][j][0] = max(f[i-1][j][1], f[i][j-1][1]) * grid[i][j]

        return f[-1][-1][1] % MOD if f[-1][-1][1] >= 0 else -1
```



## [1301. Number of Paths with Max Score](https://leetcode.com/problems/number-of-paths-with-max-score/)

+ TC O(n^2)
+ SC O(n^2)

```python
class Solution:
    def pathsWithMaxScore(self, board: List[str]) -> List[int]:
        MOD = 10 ** 9 + 7
        n = len(board)
        # [sum, cnt]
        f = [[[-inf, 0] for _ in range(n)] for _ in range(n)]

        f[0][0][0] = 0
        f[0][0][1] = 1
        for i in range(1, n):
            if board[i][0] != 'X':
                f[i][0][0] = f[i-1][0][0] + int(board[i][0])
                f[i][0][1] = 1
            else:
                break
        
        for i in range(1, n):
            if board[0][i] != 'X':
                f[0][i][0] = f[0][i-1][0] + int(board[0][i])
                f[0][i][1] = 1
            else:
                break
        
        for i in range(1, n):
            for j in range(1, n):
                if board[i][j] != 'X':
                    mx = max(f[i-1][j-1][0], f[i-1][j][0], f[i][j-1][0])
                    cnt = 0
                    if f[i-1][j-1][0] == mx:
                        cnt += f[i-1][j-1][1]
                    if f[i-1][j][0] == mx:
                        cnt += f[i-1][j][1]
                    if f[i][j-1][0] == mx:
                        cnt += f[i][j-1][1]

                    if i == n-1 and j == n-1:
                        if mx == -inf:
                            return [0, 0]
                        return [mx, cnt % MOD]
                    
                    f[i][j][0] = mx + int(board[i][j])
                    f[i][j][1] = cnt
```



## [2435. Paths in Matrix Whose Sum Is Divisible by K](https://leetcode.com/problems/paths-in-matrix-whose-sum-is-divisible-by-k/)

维护k的所有余数

+ TC O(mn)

+ SC O

```python
class Solution:
    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:
        MOD = 10 ** 9 + 7
        m, n = len(grid), len(grid[0])
        # [0%k, 1%k, 2%k, ..., (k-1)%k]
        f = [[[0] * k for _ in range(n+1)] for _ in range(m+1)]
        f[0][1][0] = 1
        for i, row in enumerate(grid):
            for j, v in enumerate(row):
                for x in range(k):
                    f[i+1][j+1][(x+v)%k] = (f[i+1][j][x] + f[i][j+1][x]) % MOD

        return f[-1][-1][0] % MOD
```



## [174. Dungeon Game](https://leetcode.com/problems/dungeon-game/)

正难则反

f(i, j) = max(min(f(i+1, j), f(i, j+1)) - dungeon(i, j),1)

+ TC O(mn)
+ SC O(mn)

```python
class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:
        m, n = len(dungeon), len(dungeon[0])
        
        @cache
        def dfs(i, j):
            if i == m-1 and j == n-1:
                return max(1 - dungeon[i][j], 1)
            
            if i == m-1:
                return max(dfs(i, j+1) - dungeon[i][j], 1)
            
            if j == n-1:
                return max(dfs(i+1, j) - dungeon[i][j], 1)

            return max(min(dfs(i+1, j), dfs(i, j+1)) - dungeon[i][j], 1)
        
        return dfs(0, 0)
```

DP递推

```python
class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:
        n, m = len(dungeon), len(dungeon[0])
        dp = [[inf] * (m + 1) for _ in range(n + 1)]
        dp[n][m - 1] = dp[n - 1][m] = 1
        for i in range(n - 1, -1, -1):
            for j in range(m - 1, -1, -1):
                dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1)

        return dp[0][0]
```

