# 8.7.1 并查集（进阶）

## [1202. Smallest String With Swaps](https://leetcode.com/problems/smallest-string-with-swaps/)

将pairs中的下标合并为一个连通块，对每个连通块里的所有字母排序

遍历s，如果当前下标在任一连通块内，替换为该连通块内最小的字母，并从连通块中移除该字母

+ TC $O(m\alpha (n) + n\log n + n\alpha(n))$ $m = len(pairs), n = len(s)$ 合并 + 排序 + 查询替换
+ SC $O(n)$

```python
class UnionFind:
    def __init__(self, n: int) -> None:
        self.root = list(range(n))
        self.size = [1] * n

    def find(self, x: int) -> int:
        if self.root[x] != x:
            self.root[x] = self.find(self.root[x])
        return self.root[x]

    def union(self, x: int, y: int) -> bool:
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return False

        if self.size[root_x] < self.size[root_y]:
            root_x, root_y = root_y, root_x
        self.root[root_y] = root_x
        self.size[root_x] += self.size[root_y]
        return True

    def is_connected(self, x: int, y: int) -> bool:
        return self.find(x) == self.find(y)


class Solution:
    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:
        n = len(s)
        uf = UnionFind(n)

        for u, v in pairs:
            uf.union(u, v)
        
        g = defaultdict(list)
        for i in range(n):
            root_i = uf.find(i)
            g[root_i].append(s[i])
        
        for k, v in g.items():
            v.sort(reverse=True)
        
        ans = []
        for i in range(n):
            root_i = uf.find(i)
            smallest_char = g[root_i][-1]
            ans.append(smallest_char)
            g[root_i].pop()
        return "".join(ans)
```



## [1061. Lexicographically Smallest Equivalent String](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/)

按字典序大小合并，大的字母合并到小的字母上

+ TC $O(n \alpha(|\Sigma|) + m \alpha(|\Sigma|))$ $n = len(s1), m = len(baseStr)$ 合并 + 查询
+ SC $O(\alpha(|\Sigma|))$

```python
class UnionFind:
    def __init__(self, n: int) -> None:
        self.root = list(range(n))
        self.size = [1] * n

    def find(self, x: int) -> int:
        if self.root[x] != x:
            self.root[x] = self.find(self.root[x])
        return self.root[x]

    def union(self, x: int, y: int) -> bool:
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return False

        if root_x > root_y:
            root_x, root_y = root_y, root_x
        self.root[root_y] = root_x
        return True

    def is_connected(self, x: int, y: int) -> bool:
        return self.find(x) == self.find(y)


class Solution:
    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:
        uf = UnionFind(26)
        for ch1, ch2 in zip(s1, s2):
            c1 = ord(ch1) - ord('a')
            c2 = ord(ch2) - ord('a')
            uf.union(c1, c2)
        
        ans = []
        for ch in baseStr:
            c = ord(ch) - ord('a')
            smallest_char = ascii_lowercase[uf.find(c)]
            ans.append(smallest_char)
        return "".join(ans)
```

