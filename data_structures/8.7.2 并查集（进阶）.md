# 8.7.1 并查集（进阶）

## [1202. Smallest String With Swaps](https://leetcode.com/problems/smallest-string-with-swaps/)

将pairs中的下标合并为一个连通块，对每个连通块里的所有字母排序

遍历s，如果当前下标在任一连通块内，替换为该连通块内最小的字母，并从连通块中移除该字母

+ TC $O(m\alpha (n) + n\log n + n\alpha(n))$ $m = len(pairs), n = len(s)$ 合并 + 排序 + 查询替换
+ SC $O(n)$

```python
class UnionFind:
    def __init__(self, n: int) -> None:
        self.root = list(range(n))
        self.size = [1] * n

    def find(self, x: int) -> int:
        if self.root[x] != x:
            self.root[x] = self.find(self.root[x])
        return self.root[x]

    def union(self, x: int, y: int) -> bool:
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return False

        if self.size[root_x] < self.size[root_y]:
            root_x, root_y = root_y, root_x
        self.root[root_y] = root_x
        self.size[root_x] += self.size[root_y]
        return True

    def is_connected(self, x: int, y: int) -> bool:
        return self.find(x) == self.find(y)


class Solution:
    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:
        n = len(s)
        uf = UnionFind(n)

        for u, v in pairs:
            uf.union(u, v)

        g = defaultdict(list)
        for i, ch in enumerate(s):
            root_i = uf.find(i)
            g[root_i].append(ch)

        for k, lst in g.items():
            lst.sort(reverse=True)

        ans = []
        for i in range(n):
            root_i = uf.find(i)
            smallest_char = g[root_i][-1]
            ans.append(smallest_char)
            g[root_i].pop()
        return "".join(ans)
```



## [1061. Lexicographically Smallest Equivalent String](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/)

按字典序大小合并，大的字母合并到小的字母上

+ TC $O(n \alpha(|\Sigma|) + m \alpha(|\Sigma|))$ $n = len(s1), m = len(baseStr)$ 合并 + 查询
+ SC $O(\alpha(|\Sigma|))$

```python
class UnionFind:
    def __init__(self, n: int) -> None:
        self.root = list(range(n))
        self.size = [1] * n

    def find(self, x: int) -> int:
        if self.root[x] != x:
            self.root[x] = self.find(self.root[x])
        return self.root[x]

    def union(self, x: int, y: int) -> bool:
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return False

        if root_x > root_y:
            root_x, root_y = root_y, root_x
        self.root[root_y] = root_x
        return True

    def is_connected(self, x: int, y: int) -> bool:
        return self.find(x) == self.find(y)


class Solution:
    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:
        uf = UnionFind(26)
        for ch1, ch2 in zip(s1, s2):
            c1 = ord(ch1) - ord('a')
            c2 = ord(ch2) - ord('a')
            uf.union(c1, c2)
        
        ans = []
        for ch in baseStr:
            c = ord(ch) - ord('a')
            smallest_char = ascii_lowercase[uf.find(c)]
            ans.append(smallest_char)
        return "".join(ans)
```



## [1722. Minimize Hamming Distance After Swap Operations](https://leetcode.com/problems/minimize-hamming-distance-after-swap-operations/)

可以swap的下标合并到一个连通块内，在根节点记录每个数字出现的次数，当source[i] != target[i]时，检查i所在连通块内是否还有多余的target[i]，如果没有，hammingdistance++

+ TC $O(m \alpha(n) + n\alpha(n))$ $n = len(source), m = len(allowedSwaps)$ 合并 + 查询
  + SC $O(n)$

```python
class UnionFind:
    def __init__(self, n: int) -> None:
        self.root = list(range(n))
        self.size = [1] * n

    def find(self, x: int) -> int:
        if self.root[x] != x:
            self.root[x] = self.find(self.root[x])
        return self.root[x]

    def union(self, x: int, y: int) -> bool:
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return False

        if self.size[root_x] < self.size[root_y]:
            root_x, root_y = root_y, root_x
        self.root[root_y] = root_x
        self.size[root_x] += self.size[root_y]
        return True

    def is_connected(self, x: int, y: int) -> bool:
        return self.find(x) == self.find(y)


class Solution:
    def minimumHammingDistance(
        self, source: List[int], target: List[int], allowedSwaps: List[List[int]]
    ) -> int:
        n = len(source)
        uf = UnionFind(n)
        for u, v in allowedSwaps:
            uf.union(u, v)

        g = defaultdict(lambda: defaultdict(int))
        for i, x in enumerate(source):
            root_i = uf.find(i)
            g[root_i][x] += 1

        ans = 0
        for i, x in enumerate(target):
            root_i = uf.find(i)
            if g[root_i][x] > 0:
                g[root_i][x] -= 1
            else:
                ans += 1
        return ans
```



## [765. Couples Holding Hands](https://leetcode.com/problems/couples-holding-hands/)

将每对情侣从0开始编号，一共n对，如果两人都已经坐在正确的位置则跳过，否则将坐错的两人所代表的两对情侣合并，视作一个置换环。每个大小为 k 的置换环需要交换 k - 1 次，假设有 $x$ 个置换环（连通块），大小分别为 $y_1, y_2, ..., y_x$，总交换次数为 $y_1 - 1 + y_2 - 1 + ... + y_x - 1 = (y_1 + y_2 + ... + y_x) - x = n - x$

+ TC $O(n \alpha (n))$
+ SC $O(n)$

```python
class UnionFind:
    def __init__(self, n: int) -> None:
        self.root = list(range(n))
        self.size = [1] * n
        self.cnt = n

    def find(self, x: int) -> int:
        if self.root[x] != x:
            self.root[x] = self.find(self.root[x])
        return self.root[x]

    def union(self, x: int, y: int) -> bool:
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return False

        if self.size[root_x] < self.size[root_y]:
            root_x, root_y = root_y, root_x
        self.root[root_y] = root_x
        self.size[root_x] += self.size[root_y]
        self.cnt -= 1
        return True

    def is_connected(self, x: int, y: int) -> bool:
        return self.find(x) == self.find(y)

class Solution:
    def minSwapsCouples(self, row: List[int]) -> int:
        n = len(row) // 2
        uf = UnionFind(n)
        for i in range(0, 2 * n, 2):
            x = row[i] // 2
            y = row[i + 1] // 2
            uf.union(x, y)

        return n - uf.cnt
```

贪心：每次固定一个位置 i, 找row[i] = x对应的情侣 x ^ 1 所在的下标j，把 j 换到i + 1处。

每次交换实际上就是在一个环内部交换两个节点的位置。如果一个环有 k 个节点，那么需要 k − 1 次交换来确保每个节点都与其配对的情侣相邻。这是因为每次交换都会减少环中未正确配对的情侣对的数量。

贪心策略的正确性：在每个环内部，我们每次交换都会确保至少有一对情侣正确地坐在了一起，从而减少环的长度。这种方式确保我们以最小的交换次数实现目标。由于每个环是独立的，我们可以单独考虑每个环，而每个环内部的操作不会影响其他环。因此，对于每个环，我们都在实现局部最优解，这最终导致了全局最优解。

```python
class Solution:
    def minSwapsCouples(self, row: List[int]) -> int:
        val_to_idx = {x: i for i, x in enumerate(row)}
        n = len(row)
        ans = 0
        for i in range(0, n, 2):
            if row[i] // 2 == row[i + 1] // 2:
                continue
            x = row[i]
            x_target = x ^ 1 # x的目标另一半
            x_target_index = val_to_idx[x_target]

            y = row[i + 1]
            # 因为从左往右遍历，每次固定好一对情侣，不用更新x的另一半的idx信息
            # 只需要把本来坐在x右边的人移到x的目标另一半之前的位置x_target_index
            row[x_target_index] = y 
            val_to_idx[y] = x_target_index
            ans += 1
        return ans
```



## [684. Redundant Connection](https://leetcode.com/problems/redundant-connection/)

判断哪一条边成环，即求哪条边尝试合并已经在同一连通块内的两个节点

+ TC $O(n \alpha (n))$
+ SC $O(n)$

```python
class UnionFind:
    def __init__(self, n: int) -> None:
        self.root = list(range(n))
        self.size = [1] * n

    def find(self, x: int) -> int:
        if self.root[x] != x:
            self.root[x] = self.find(self.root[x])
        return self.root[x]

    def union(self, x: int, y: int) -> bool:
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return False

        if self.size[root_x] < self.size[root_y]:
            root_x, root_y = root_y, root_x
        self.root[root_y] = root_x
        self.size[root_x] += self.size[root_y]
        return True

    def is_connected(self, x: int, y: int) -> bool:
        return self.find(x) == self.find(y)


class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        n = len(edges)
        uf = UnionFind(n + 1)

        for x, y in edges:
            if not uf.union(x, y):
                return [x, y]
        
        return []
```



## [685. Redundant Connection II](https://leetcode.com/problems/redundant-connection-ii/)

有向图因为多了一条边而不是树会有两种情况：

1. 存在一个节点有两个父节点，即入度为2
2. 成环

+ TC $O(n + n \alpha (n))$
+ SC $O(n)$

```python
class UnionFind:
    def __init__(self, n: int) -> None:
        self.root = list(range(n))
        self.size = [1] * n

    def find(self, x: int) -> int:
        if self.root[x] != x:
            self.root[x] = self.find(self.root[x])
        return self.root[x]

    def union(self, x: int, y: int) -> bool:
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return False

        if self.size[root_x] < self.size[root_y]:
            root_x, root_y = root_y, root_x
        self.root[root_y] = root_x
        self.size[root_x] += self.size[root_y]
        return True

    def is_connected(self, x: int, y: int) -> bool:
        return self.find(x) == self.find(y)


class Solution:
    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:
        # 判断删除一条边edges[idx]后，是否是valid tree
        def isValidTree(edges, idx):
            uf = UnionFind(len(edges) + 1)
            for i, edge in enumerate(edges):
                if i == idx:
                    continue

                x, y = edge
                if not uf.union(x, y):
                    return False

            return True

        n = len(edges)

        indegree = [0] * (n + 1)
        for edge in edges:
            x, y = edge
            indegree[y] += 1

        # 入度为2，有一个节点有两个父节点，移除最后出现的一条边即可
        edge_indexes_with_indegree2 = []
        for i in range(n - 1, -1, -1):
            if indegree[edges[i][1]] == 2:
                edge_indexes_with_indegree2.append(i)

        if len(edge_indexes_with_indegree2) == 2:
            if isValidTree(edges, edge_indexes_with_indegree2[0]):
                return edges[edge_indexes_with_indegree2[0]]
            return edges[edge_indexes_with_indegree2[1]]

        # 没有入度为2的节点
        # 删除成环边即可
        uf = UnionFind(n + 1)
        for x, y in edges:
            if not uf.union(x, y):
                return [x, y]

        return []

```



## [947. Most Stones Removed with Same Row or Column](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/)

正难则反，从前往后遍历，如果有其他石头和当前石头共享相同行/列就合并到同一连通块内，答案即为n - uf.cnt

+ TC $O(n \alpha (n))$
+ SC $O(n)$

```python
class UnionFind:
    def __init__(self, n: int) -> None:
        self.root = list(range(n))
        self.size = [1] * n
        self.cnt = n

    def find(self, x: int) -> int:
        if self.root[x] != x:
            self.root[x] = self.find(self.root[x])
        return self.root[x]

    def union(self, x: int, y: int) -> bool:
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return False

        if self.size[root_x] < self.size[root_y]:
            root_x, root_y = root_y, root_x
        self.root[root_y] = root_x
        self.size[root_x] += self.size[root_y]
        self.cnt -= 1
        return True

    def is_connected(self, x: int, y: int) -> bool:
        return self.find(x) == self.find(y)


class Solution:
    def removeStones(self, stones: List[List[int]]) -> int:
        n = len(stones)
        uf = UnionFind(n)
        xs = defaultdict(list) # 记录{row: [stone_idx]}
        ys = defaultdict(list) # 记录{col: [stone_idx]}

        for i, (x, y) in enumerate(stones):
            for j in xs[x] + ys[y]:
                uf.union(i, j) # stone i and j share either same row or same col

            xs[x].append(i)
            ys[y].append(i)

        return n - uf.cnt
```

