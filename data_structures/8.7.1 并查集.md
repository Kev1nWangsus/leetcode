# 8.7.1 并查集

并查集 Union Find / Disjoint Set 是一种用于维护联通块/管理元素所属集合的数据结构。实现为一个森林，其中每个树表示一个集合，树中的节点表示对应集合中的元素，指向自己的父亲节点。一般选择一棵树的根节点作为代表。

并查集支持两种操作

1. 查询 (Find)：查询某个元素所属集合（查询对应的树的根节点）
2. 合并 (Union)：合并两个元素所属集合

并查集在经过修改后可以支持单个元素的删除、移动；使用动态开点线段树还可以实现可持久化并查集。



使用路径压缩和启发式合并后，平均摊还时间复杂度为 $O(\alpha(n))$ 这里 $\alpha$ 是反阿克曼函数，对人类可观测的最大 $n$ 来说，$\alpha(n) < 5$ 

最坏时间复杂度仍为 $O(\log(n))$



并查集模板

```python
class UnionFind:
    def __init__(self, n: int) -> None:
        self.root = list(range(n))
        self.size = [1] * n
    
    def find(self, x: int) -> int:
        if self.root[x] != x:
            self.root[x] = self.find(self.root[x])
        return self.root[x]
    
    def union(self, x: int, y: int) -> bool:
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return False

        if self.size[root_x] < self.size[root_y]:
            root_x, root_y = root_y, root_x
        self.root[root_y] = root_x
        self.size[root_x] += self.size[root_y]
        return True
   	
    def is_connected(self, x: int, y: int) -> bool:
        return self.find(x) == self.find(y)
```



并查集模板 + comment

```python
class UnionFind:
    def __init__(self, n: int) -> None:
        self.root = list(range(n))  # 维护父亲节点，指向自己时表示根节点
        self.size = [1] * n  # 当前根节点代表的联通块的大小（树中节点的个数）

    def find(self, x: int) -> int:
        # 查询 + 路径压缩优化
        # 沿着树不断查询父亲节点向上移动，直到找到根节点
        if self.root[x] != x:
            # 向上移动的过程中，将路径上的所有节点都指向根节点，扁平化这颗树
            self.root[x] = self.find(self.root[x])
        return self.root[x]

    def union(self, x: int, y: int) -> bool:
        # 合并 + 启发式合并优化
        # 如果两点已经在一个联通块内，则不合并
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return False

        # 将一棵小树连到一棵大树上
        if self.size[root_x] < self.size[root_y]:
            root_x, root_y = root_y, root_x
        self.root[root_y] = root_x
        self.size[root_x] += self.size[root_y]
        return True
	
	def is_connected(self, x: int, y: int) -> bool:
        return self.find(x) == self.find(y)
```



## [990. Satisfiability of Equality Equations](https://leetcode.com/problems/satisfiability-of-equality-equations/)

相等就合并 不相等但是在同一联通块内就不合法



并查集

+ TC $O(n \alpha(|\Sigma|))$
+ SC $O(|\Sigma|)$

```python
class UnionFind:
    def __init__(self, n: int) -> None:
        self.root = list(range(n))
        self.size = [1] * n

    def find(self, x: int) -> int:
        if self.root[x] != x:
            self.root[x] = self.find(self.root[x])
        return self.root[x]

    def union(self, x: int, y: int) -> bool:
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return False

        if self.size[root_x] < self.size[root_y]:
            root_x, root_y = root_y, root_x
        self.root[root_y] = root_x
        self.size[root_x] += self.size[root_y]
        return True

    def is_connected(self, x: int, y: int) -> bool:
        return self.find(x) == self.find(y)


class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        uf = UnionFind(26)
        uf = UnionFind(26)
        for eq in equations:
            if eq[1] == "=":
                x = ord(eq[0]) - ord("a")
                y = ord(eq[-1]) - ord("a")
                uf.union(x, y)

        for eq in equations:
            if eq[1] == "!":
                x = ord(eq[0]) - ord("a")
                y = ord(eq[-1]) - ord("a")
                if uf.is_connected(x, y):
                    return False

        return True
```



DFS

+ TC $O(n + |\Sigma|)$
+ SC $O(n + |\Sigma|)$

```python
class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
       graph = [[] for _ in range(26)]

        for eq in equations:
            if eq[1] == "=":
                x = ord(eq[0]) - ord("a")
                y = ord(eq[3]) - ord("a")
                graph[x].append(y)
                graph[y].append(x)

        color = [-1] * 26

   `     def dfs(x, c):
            if color[x] == -1:
                color[x] = c
                for nei in graph[x]:
                    dfs(nei, c)

        for i in range(26):
            dfs(i, i)

        for eq in equations:
            if eq[1] == "!":
                x = ord(eq[0]) - ord("a")
                y = ord(eq[3]) - ord("a")
                if color[x] == color[y]:
                    return False
        return True
```

